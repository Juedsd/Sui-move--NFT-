var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _host, _path, _keypair, _client, _redirect, _objects, _balances, _sender, _coinsByType, _estimateClaimGasFee, estimateClaimGasFee_fn, _getCoinsByType, getCoinsByType_fn, _client2, _keypair2, _initiallyOwnedObjects, _ownedObjects, _gasCoin, _hasSui, _creatorAddress, _loadOwnedObjects, loadOwnedObjects_fn, _loadInitialTransactionData, loadInitialTransactionData_fn;
import { getFullnodeUrl, SuiClient } from "@mysten/sui.js/client";
import { decodeSuiPrivateKey } from "@mysten/sui.js/cryptography";
import { Ed25519Keypair } from "@mysten/sui.js/keypairs/ed25519";
import { TransactionBlock } from "@mysten/sui.js/transactions";
import {
  fromB64,
  normalizeStructTag,
  normalizeSuiAddress,
  normalizeSuiObjectId,
  parseStructTag,
  SUI_TYPE_ARG,
  toB64
} from "@mysten/sui.js/utils";
const DEFAULT_ZK_SEND_LINK_OPTIONS = {
  host: "https://zksend.com",
  path: "/claim",
  client: new SuiClient({ url: getFullnodeUrl("mainnet") })
};
const SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);
const SUI_COIN_OBJECT_TYPE = normalizeStructTag("0x2::coin::Coin<0x2::sui::SUI>");
class ZkSendLinkBuilder {
  constructor({
    host = DEFAULT_ZK_SEND_LINK_OPTIONS.host,
    path = DEFAULT_ZK_SEND_LINK_OPTIONS.path,
    keypair = new Ed25519Keypair(),
    client = DEFAULT_ZK_SEND_LINK_OPTIONS.client,
    sender,
    redirect
  }) {
    __privateAdd(this, _estimateClaimGasFee);
    __privateAdd(this, _getCoinsByType);
    __privateAdd(this, _host, void 0);
    __privateAdd(this, _path, void 0);
    __privateAdd(this, _keypair, void 0);
    __privateAdd(this, _client, void 0);
    __privateAdd(this, _redirect, void 0);
    __privateAdd(this, _objects, /* @__PURE__ */ new Set());
    __privateAdd(this, _balances, /* @__PURE__ */ new Map());
    __privateAdd(this, _sender, void 0);
    __privateAdd(this, _coinsByType, /* @__PURE__ */ new Map());
    __privateSet(this, _host, host);
    __privateSet(this, _path, path);
    __privateSet(this, _redirect, redirect);
    __privateSet(this, _keypair, keypair);
    __privateSet(this, _client, client);
    __privateSet(this, _sender, normalizeSuiAddress(sender));
  }
  addClaimableMist(amount) {
    this.addClaimableBalance(SUI_COIN_TYPE, amount);
  }
  addClaimableBalance(coinType, amount) {
    const normalizedType = normalizeStructTag(coinType);
    __privateGet(this, _balances).set(normalizedType, (__privateGet(this, _balances).get(normalizedType) ?? 0n) + amount);
  }
  addClaimableObject(id) {
    __privateGet(this, _objects).add(id);
  }
  getLink() {
    const link = new URL(__privateGet(this, _host));
    link.pathname = __privateGet(this, _path);
    link.hash = toB64(decodeSuiPrivateKey(__privateGet(this, _keypair).getSecretKey()).secretKey);
    if (__privateGet(this, _redirect)) {
      link.searchParams.set("redirect_url", __privateGet(this, _redirect).url);
      if (__privateGet(this, _redirect).name) {
        link.searchParams.set("name", __privateGet(this, _redirect).name);
      }
    }
    return link.toString();
  }
  async create({
    signer,
    ...options
  }) {
    const txb = await this.createSendTransaction(options);
    return __privateGet(this, _client).signAndExecuteTransactionBlock({
      transactionBlock: await txb.build({ client: __privateGet(this, _client) }),
      signer
    });
  }
  async createSendTransaction({
    transactionBlock: txb = new TransactionBlock(),
    calculateGas
  } = {}) {
    const gasEstimateFromDryRun = await __privateMethod(this, _estimateClaimGasFee, estimateClaimGasFee_fn).call(this);
    const baseGasAmount = calculateGas ? await calculateGas({
      balances: __privateGet(this, _balances),
      objects: [...__privateGet(this, _objects)],
      gasEstimateFromDryRun
    }) : gasEstimateFromDryRun * 2n;
    const gasWithBuffer = baseGasAmount + 1013n;
    const roundedGasAmount = gasWithBuffer - gasWithBuffer % 1000n - 13n;
    const address = __privateGet(this, _keypair).toSuiAddress();
    const objectsToTransfer = [...__privateGet(this, _objects)].map((id) => txb.object(id));
    const [gas] = txb.splitCoins(txb.gas, [roundedGasAmount]);
    objectsToTransfer.push(gas);
    txb.setSenderIfNotSet(__privateGet(this, _sender));
    for (const [coinType, amount] of __privateGet(this, _balances)) {
      if (coinType === SUI_COIN_TYPE) {
        const [sui] = txb.splitCoins(txb.gas, [amount]);
        objectsToTransfer.push(sui);
      } else {
        const coins = (await __privateMethod(this, _getCoinsByType, getCoinsByType_fn).call(this, coinType)).map((coin) => coin.coinObjectId);
        if (coins.length > 1) {
          txb.mergeCoins(coins[0], coins.slice(1));
        }
        const [split] = txb.splitCoins(coins[0], [amount]);
        objectsToTransfer.push(split);
      }
    }
    txb.transferObjects(objectsToTransfer, address);
    return txb;
  }
}
_host = new WeakMap();
_path = new WeakMap();
_keypair = new WeakMap();
_client = new WeakMap();
_redirect = new WeakMap();
_objects = new WeakMap();
_balances = new WeakMap();
_sender = new WeakMap();
_coinsByType = new WeakMap();
_estimateClaimGasFee = new WeakSet();
estimateClaimGasFee_fn = async function() {
  const txb = new TransactionBlock();
  txb.setSender(__privateGet(this, _sender));
  txb.setGasPayment([]);
  txb.transferObjects([txb.gas], __privateGet(this, _keypair).toSuiAddress());
  const idsToTransfer = [...__privateGet(this, _objects)];
  for (const [coinType] of __privateGet(this, _balances)) {
    const coins = await __privateMethod(this, _getCoinsByType, getCoinsByType_fn).call(this, coinType);
    if (!coins.length) {
      throw new Error(`Sending account does not contain any coins of type ${coinType}`);
    }
    idsToTransfer.push(coins[0].coinObjectId);
  }
  if (idsToTransfer.length > 0) {
    txb.transferObjects(
      idsToTransfer.map((id) => txb.object(id)),
      __privateGet(this, _keypair).toSuiAddress()
    );
  }
  const result = await __privateGet(this, _client).dryRunTransactionBlock({
    transactionBlock: await txb.build({ client: __privateGet(this, _client) })
  });
  return BigInt(result.effects.gasUsed.computationCost) + BigInt(result.effects.gasUsed.storageCost) - BigInt(result.effects.gasUsed.storageRebate);
};
_getCoinsByType = new WeakSet();
getCoinsByType_fn = async function(coinType) {
  if (__privateGet(this, _coinsByType).has(coinType)) {
    return __privateGet(this, _coinsByType).get(coinType);
  }
  const coins = await __privateGet(this, _client).getCoins({
    coinType,
    owner: __privateGet(this, _sender)
  });
  __privateGet(this, _coinsByType).set(coinType, coins.data);
  return coins.data;
};
const _ZkSendLink = class {
  constructor({
    client = DEFAULT_ZK_SEND_LINK_OPTIONS.client,
    keypair = new Ed25519Keypair()
  }) {
    __privateAdd(this, _loadOwnedObjects);
    __privateAdd(this, _loadInitialTransactionData);
    __privateAdd(this, _client2, void 0);
    __privateAdd(this, _keypair2, void 0);
    __privateAdd(this, _initiallyOwnedObjects, /* @__PURE__ */ new Set());
    __privateAdd(this, _ownedObjects, []);
    __privateAdd(this, _gasCoin, void 0);
    __privateAdd(this, _hasSui, false);
    __privateAdd(this, _creatorAddress, void 0);
    __privateSet(this, _client2, client);
    __privateSet(this, _keypair2, keypair);
  }
  static async fromUrl(url, options) {
    const parsed = new URL(url);
    const keypair = Ed25519Keypair.fromSecretKey(fromB64(parsed.hash.slice(1)));
    const link = new _ZkSendLink({
      ...options,
      keypair
    });
    await link.loadOwnedData();
    return link;
  }
  async loadOwnedData() {
    await Promise.all([__privateMethod(this, _loadInitialTransactionData, loadInitialTransactionData_fn).call(this), __privateMethod(this, _loadOwnedObjects, loadOwnedObjects_fn).call(this)]);
  }
  async listClaimableAssets(address, options) {
    const normalizedAddress = normalizeSuiAddress(address);
    const txb = this.createClaimTransaction(normalizedAddress, options);
    if (__privateGet(this, _gasCoin) || !__privateGet(this, _hasSui)) {
      txb.setGasPayment([]);
    }
    const dryRun = await __privateGet(this, _client2).dryRunTransactionBlock({
      transactionBlock: await txb.build({ client: __privateGet(this, _client2) })
    });
    const balances = [];
    const nfts = [];
    dryRun.balanceChanges.forEach((balanceChange) => {
      if (BigInt(balanceChange.amount) > 0n && isOwner(balanceChange.owner, normalizedAddress)) {
        balances.push({ coinType: balanceChange.coinType, amount: BigInt(balanceChange.amount) });
      }
    });
    dryRun.objectChanges.forEach((objectChange) => {
      if ("objectType" in objectChange) {
        const type = parseStructTag(objectChange.objectType);
        if (type.address === normalizeSuiAddress("0x2") && type.module === "coin" && type.name === "Coin") {
          return;
        }
      }
      if (ownedAfterChange(objectChange, normalizedAddress)) {
        nfts.push(objectChange);
      }
    });
    return {
      balances,
      nfts
    };
  }
  async claimAssets(address, options) {
    return __privateGet(this, _client2).signAndExecuteTransactionBlock({
      transactionBlock: await this.createClaimTransaction(address, options),
      signer: __privateGet(this, _keypair2)
    });
  }
  createClaimTransaction(address, options) {
    const claimAll = !options?.coinTypes && !options?.objects;
    const txb = new TransactionBlock();
    txb.setSender(__privateGet(this, _keypair2).toSuiAddress());
    const coinTypes = new Set(
      options?.coinTypes?.map((type) => normalizeStructTag(`0x2::coin::Coin<${type}>`)) ?? []
    );
    const objectsToTransfer = __privateGet(this, _ownedObjects).filter((object) => {
      if (__privateGet(this, _gasCoin)) {
        if (object.objectId === __privateGet(this, _gasCoin).coinObjectId) {
          return false;
        }
      } else if (object.type === SUI_COIN_OBJECT_TYPE) {
        return false;
      }
      if (coinTypes?.has(object.type) || options?.objects?.includes(object.objectId)) {
        return true;
      }
      if (!options?.claimObjectsAddedAfterCreation && !__privateGet(this, _initiallyOwnedObjects).has(object.objectId)) {
        return false;
      }
      return claimAll;
    }).map((object) => txb.object(object.objectId));
    if (__privateGet(this, _gasCoin) && __privateGet(this, _creatorAddress)) {
      txb.transferObjects([txb.gas], __privateGet(this, _creatorAddress));
    } else if (claimAll || coinTypes?.has(SUI_COIN_TYPE)) {
      objectsToTransfer.push(txb.gas);
    }
    if (objectsToTransfer.length > 0) {
      txb.transferObjects(objectsToTransfer, address);
    }
    return txb;
  }
};
let ZkSendLink = _ZkSendLink;
_client2 = new WeakMap();
_keypair2 = new WeakMap();
_initiallyOwnedObjects = new WeakMap();
_ownedObjects = new WeakMap();
_gasCoin = new WeakMap();
_hasSui = new WeakMap();
_creatorAddress = new WeakMap();
_loadOwnedObjects = new WeakSet();
loadOwnedObjects_fn = async function() {
  __privateSet(this, _ownedObjects, []);
  let nextCursor;
  const owner = __privateGet(this, _keypair2).toSuiAddress();
  do {
    const ownedObjects = await __privateGet(this, _client2).getOwnedObjects({
      cursor: nextCursor,
      owner,
      options: {
        showType: true
      }
    });
    nextCursor = ownedObjects.hasNextPage ? ownedObjects.nextCursor : null;
    for (const object of ownedObjects.data) {
      if (object.data) {
        __privateGet(this, _ownedObjects).push({
          objectId: normalizeSuiObjectId(object.data.objectId),
          version: object.data.version,
          digest: object.data.digest,
          type: normalizeStructTag(object.data.type)
        });
      }
    }
  } while (nextCursor);
  const coins = await __privateGet(this, _client2).getCoins({
    coinType: SUI_COIN_TYPE,
    owner
  });
  __privateSet(this, _hasSui, coins.data.length > 0);
  __privateSet(this, _gasCoin, coins.data.find((coin) => BigInt(coin.balance) % 1000n === 987n));
};
_loadInitialTransactionData = new WeakSet();
loadInitialTransactionData_fn = async function() {
  const address = __privateGet(this, _keypair2).toSuiAddress();
  const result = await __privateGet(this, _client2).queryTransactionBlocks({
    limit: 1,
    order: "ascending",
    filter: {
      ToAddress: address
    },
    options: {
      showObjectChanges: true,
      showInput: true
    }
  });
  result.data[0]?.objectChanges?.forEach((objectChange) => {
    if (ownedAfterChange(objectChange, address)) {
      __privateGet(this, _initiallyOwnedObjects).add(normalizeSuiObjectId(objectChange.objectId));
    }
  });
  __privateSet(this, _creatorAddress, result.data[0]?.transaction?.data.sender);
};
function ownedAfterChange(objectChange, address) {
  if (objectChange.type === "transferred" && isOwner(objectChange.recipient, address)) {
    return true;
  }
  if ((objectChange.type === "created" || objectChange.type === "mutated") && isOwner(objectChange.owner, address)) {
    return true;
  }
  return false;
}
function isOwner(owner, address) {
  return owner && typeof owner === "object" && "AddressOwner" in owner && normalizeSuiAddress(owner.AddressOwner) === address;
}
export {
  ZkSendLink,
  ZkSendLinkBuilder
};
//# sourceMappingURL=links.js.map
